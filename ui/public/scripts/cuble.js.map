{
  "version": 3,
  "sources": ["../../src/scripts/pieceIndices.ts", "../../src/scripts/scene.ts", "../../src/scripts/ui.ts", "../../src/scripts/cuble.ts"],
  "sourcesContent": ["export const CENTERS = [4, 13, 22, 31, 40, 49];\r\nexport const UBL = [0, 29, 36];\r\nexport const URB = [6, 35, 51];\r\nexport const ULF = [2, 9, 42];\r\nexport const UFR = [8, 15, 45];\r\nexport const DFL = [18, 11, 44];\r\nexport const DRF = [24, 47, 17];\r\nexport const DLB = [20, 38, 27];\r\nexport const DBR = [26, 33, 53];\r\nexport const UB = [3, 32];\r\nexport const UL = [1, 39];\r\nexport const UR = [7, 48];\r\nexport const UF = [5, 12];\r\nexport const FL = [10, 43];\r\nexport const FR = [16, 46];\r\nexport const DF = [21, 14];\r\nexport const DL = [19, 41];\r\nexport const DR = [25, 50];\r\nexport const DB = [23, 30];\r\nexport const BL = [28, 37];\r\nexport const BR = [34, 52];\r\nexport const layer1Corners = [...UBL, ...URB, ...ULF, ...UFR];\r\nexport const layer2Corners = [...DFL, ...DRF, ...DLB, ...DBR];\r\nexport const layer1Edges = [...UB, ...UL, ...UR, ...UF];\r\nexport const layer2Edges = [...FL, ...FR, ...BL, ...BR];\r\nexport const layer3Edges = [...DF, ...DL, ...DR, ...DB];\r\nexport const cross = [...CENTERS, ...layer1Edges];\r\nexport const firstLayer = [...cross, ...layer1Corners];\r\nexport const f2l = [...firstLayer, ...layer2Edges];\r\nexport const lastLayer = [...layer3Edges, ...layer2Corners];\r\nexport const allPieces = [...f2l, ...lastLayer];", "import { BufferObject, createBuffers } from \"./buffers\";\r\nimport { Spring } from \"./common/spring\";\r\nimport { CubeLogic } from \"./cube\";\r\nimport { DragDetector } from \"./dragDetector\";\r\nimport * as glMat from \"./glMatrix\";\r\nimport * as store from \"./store\";\r\n\r\nlet canvas: HTMLCanvasElement = document.querySelector(\"canvas\");\r\nlet gl: WebGLRenderingContext = canvas.getContext(\"webgl\");\r\n\r\ntype ProgramInfo = {\r\n    attribLocations: {\r\n        vertexPosition: number,\r\n        vertexColor: number,\r\n    },\r\n    uniformLocations: {\r\n        transformMatrix: WebGLUniformLocation,\r\n    },\r\n};\r\n\r\nlet programInfo: ProgramInfo = initPrograms();\r\n\r\nexport type Scene = {\r\n    div: HTMLElement,\r\n    cube: CubeLogic,\r\n    spring: Spring,\r\n    buffers: BufferObject[],\r\n    transformMatrix: number[],\r\n};\r\nexport let scenes: Scene[] = [];\r\n\r\nlet time: number = Date.now() * 0.001;\r\n\r\nlet prefsLoaded = false;\r\nlet numLayers: number = 3;\r\nlet dragEnabled = true;\r\n\r\n// Preferences stored locally\r\nlet sizeMultiplier: number;\r\nlet offsetSelection = 1;\r\nexport let hintStickers = true;\r\nexport let showBody = true;\r\nexport let animateTurns = true;\r\n\r\nlet loopStarted = false;\r\nexport function startLoop() {\r\n    if (loopStarted) return;\r\n    loopStarted = true;\r\n    requestAnimationFrame(render);\r\n}\r\n\r\nfunction loadPrefs() {\r\n    if (prefsLoaded) return;\r\n    prefsLoaded = true;\r\n    sizeMultiplier = store.getSize();\r\n    offsetSelection = store.getAngle();\r\n    hintStickers = store.getHintStickers();\r\n    showBody = store.getShowBody();\r\n    animateTurns = store.getAnimateTurns();\r\n}\r\n\r\nexport function setNumLayers(val: number) {\r\n    numLayers = val;\r\n    // renderCanvas();\r\n    // TODO\r\n}\r\n\r\nexport function setSizeMultiplier(val: number) {\r\n    sizeMultiplier = val;\r\n}\r\n\r\n/**\r\n * value = 0 --> left\r\n * value = 1 --> head-on\r\n * value = 2 --> right\r\n */\r\nexport function setAngleOffset(value: number) {\r\n    offsetSelection = value;\r\n    // renderCanvas();\r\n    // TODO\r\n}\r\n\r\nexport function setHintStickers(val: boolean) {\r\n    hintStickers = val;\r\n    // render(null, null); // TODO\r\n}\r\n\r\nexport function setShowBody(val: boolean) {\r\n    showBody = val;\r\n    // buffers.initBufferData(cube, showBody, transformMatrix);\r\n    // render(null); // TODO\r\n}\r\n\r\nexport function setAnimateTurns(val: boolean) {\r\n    animateTurns = val;\r\n    // cube.animateTurns = val;\r\n}\r\n\r\nexport function setDragEnabled(val: boolean) {\r\n    dragEnabled = val;\r\n}\r\n\r\nexport function newScene(selector: string): Scene {\r\n    let div = document.querySelector(selector) as HTMLElement;\r\n    let cube = new CubeLogic(gl, true);\r\n    let spring = new Spring();\r\n    let transformMatrix = initTransform(div);\r\n    let dragDetector = new DragDetector();\r\n    \r\n    cube.setNumOfLayers(numLayers);\r\n    cube.new();\r\n\r\n    let buffers = createBuffers(gl, cube, true, transformMatrix);\r\n\r\n    const pointerdown = (offsetX, offsetY) => {\r\n        if (!dragEnabled) return;\r\n        dragDetector.onPointerDown(offsetX, offsetY, div, cube, buffers, offsetSelection);\r\n    }\r\n\r\n    const pointermove = (offsetX, offsetY) => {\r\n        if (!dragEnabled) return;\r\n        dragDetector.onPointerMove(offsetX, offsetY);\r\n    }\r\n\r\n    const pointerup = () => {\r\n        if (!dragEnabled) return;\r\n        dragDetector.onPointerUp(div, cube, buffers, offsetSelection);\r\n    }\r\n\r\n    const calcOffset = (event) => {\r\n        const rect = event.target.getBoundingClientRect();\r\n        const x = event.touches[0].pageX - rect.left;\r\n        const y = event.touches[0].pageY - rect.top;\r\n        return { x, y };\r\n    }\r\n\r\n    const addPointerListeners = () => {\r\n        div.addEventListener(\"pointerdown\", event => pointerdown(event.offsetX, event.offsetY));\r\n        div.addEventListener(\"pointermove\", event => pointermove(event.offsetX, event.offsetY));\r\n        div.addEventListener(\"pointerup\", event => pointerup());\r\n    }\r\n\r\n    const addTouchListeners = () => {\r\n        div.addEventListener(\"touchstart\", event => {\r\n            const { x, y } = calcOffset(event);\r\n            pointerdown(x, y);\r\n        });\r\n        div.addEventListener(\"touchmove\", event => {\r\n            const { x, y } = calcOffset(event);\r\n            pointermove(x, y);\r\n        });\r\n        div.addEventListener(\"touchend\", event => {\r\n            pointerup();\r\n        });\r\n    }\r\n\r\n    if (window.PointerEvent) {\r\n        addPointerListeners();\r\n    } else {\r\n        addTouchListeners();\r\n    }\r\n\r\n    return {\r\n        div,\r\n        cube,\r\n        spring,\r\n        buffers,\r\n        transformMatrix,\r\n    };\r\n}\r\n\r\nfunction initPrograms() {\r\n    const vertexShaderSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n    uniform mat4 uTransformMatrix;\r\n    varying lowp vec4 vColor;\r\n    void main(void) {\r\n        gl_Position = uTransformMatrix * aVertexPosition;\r\n        vColor = aVertexColor;\r\n    }\r\n    `;\r\n\r\n    const fragmentShaderSource = `\r\n    varying lowp vec4 vColor;\r\n    void main(void) {\r\n        gl_FragColor = vColor;\r\n    }\r\n    `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vertexShaderSource, fragmentShaderSource);\r\n\r\n    gl.useProgram(shaderProgram);\r\n\r\n    return {\r\n        attribLocations: {\r\n            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n            vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),\r\n        },\r\n        uniformLocations: {\r\n            transformMatrix: gl.getUniformLocation(shaderProgram, 'uTransformMatrix'),\r\n        }\r\n    }\r\n}\r\n\r\nfunction initTransform(element: HTMLElement) {\r\n    const xOpts = [35, 45, 35];\r\n    const yOpts = [-45, 0, 45];\r\n    let xAxis = xOpts[offsetSelection] * Math.PI / 180;\r\n    let yAxis = yOpts[offsetSelection] * Math.PI / 180;\r\n\r\n    let transformMatrix = glMat.create();\r\n\r\n    glMat.perspective(transformMatrix,\r\n        50 * Math.PI / 180, // field of view\r\n        element.clientWidth / element.clientHeight, // aspect\r\n        0.1, // z near\r\n        100.0); // z far\r\n\r\n    glMat.translate(transformMatrix,\r\n        [0.0, 0.0, -5.0]);\r\n\r\n    glMat.rotate(transformMatrix,\r\n        transformMatrix,\r\n        xAxis,\r\n        [1, 0, 0],\r\n    );\r\n\r\n    glMat.rotate(transformMatrix,\r\n        transformMatrix,\r\n        yAxis,\r\n        [0, -1, 0],\r\n    );\r\n\r\n    return transformMatrix;\r\n}\r\n\r\nfunction bindPosition(positionBuffer: WebGLBuffer, programInfo: ProgramInfo, gl: WebGLRenderingContext) {\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        3, // size\r\n        gl.FLOAT, // type\r\n        false, // normalize\r\n        0, // stride\r\n        0); // offset\r\n    gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexPosition);\r\n}\r\n\r\nfunction bindColor(colorBuffer: WebGLBuffer, programInfo: ProgramInfo, gl: WebGLRenderingContext) {\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        4, // size\r\n        gl.FLOAT, // type\r\n        false, // normalize\r\n        0, // stride\r\n        0); // offset\r\n    gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexColor);\r\n}\r\n\r\nfunction drawElements(gl: WebGLRenderingContext) {\r\n    gl.drawElements(\r\n        gl.TRIANGLES,\r\n        6,\r\n        gl.UNSIGNED_SHORT, // type\r\n        0, // offset\r\n    );\r\n}\r\n\r\n// Initialize a shader program, so WebGL knows how to draw our data\r\nfunction initShaderProgram(gl, vsSource, fsSource) {\r\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n        return null;\r\n    }\r\n\r\n    return shaderProgram;\r\n}\r\n\r\n// Creates a shader of the given type, uploads the source and compiles it.\r\nfunction loadShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n\r\n    gl.shaderSource(shader, source);\r\n\r\n    gl.compileShader(shader);\r\n\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n\r\n    return shader;\r\n}\r\n\r\nfunction resizeCanvasToDisplaySize() {\r\n    // Lookup the size the browser is displaying the canvas in CSS pixels.\r\n    const displayWidth = canvas.clientWidth;\r\n    const displayHeight = canvas.clientHeight;\r\n\r\n    // Check if the canvas is not the same size.\r\n    const needResize = canvas.width !== displayWidth ||\r\n        canvas.height !== displayHeight;\r\n\r\n    if (needResize) {\r\n        // Make the canvas the same size\r\n        canvas.width = displayWidth;\r\n        canvas.height = displayHeight;\r\n    }\r\n\r\n    return needResize;\r\n}\r\n\r\nfunction render(newTime: number) {\r\n    newTime *= 0.001; // convert to seconds\r\n    const dt = newTime - time;\r\n    time = newTime;\r\n\r\n    resizeCanvasToDisplaySize();\r\n\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.enable(gl.SCISSOR_TEST);\r\n    gl.depthFunc(gl.LEQUAL); // Near things obscure far things\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    // move the canvas to top of the current scroll position\r\n    canvas.style.transform = `translateY(${window.scrollY}px)`;\r\n\r\n    for (let i = 0; i < scenes.length; i++) {\r\n        const { cube, div, spring, buffers, transformMatrix } = scenes[i];\r\n\r\n        const rect = div.getBoundingClientRect();\r\n        if (rect.bottom < 0 || rect.top > canvas.clientHeight ||\r\n            rect.right < 0 || rect.left > canvas.clientWidth) {\r\n            continue;  // it's off screen\r\n        }\r\n\r\n        const width = rect.right - rect.left;\r\n        const height = rect.bottom - rect.top;\r\n        const left = rect.left;\r\n        const bottom = canvas.clientHeight - rect.bottom;\r\n\r\n        gl.viewport(left, bottom, width, height);\r\n        gl.scissor(left, bottom, width, height);\r\n\r\n        if (cube.animationQueue[0]) {\r\n            // target is measured in degrees\r\n            spring.target = cube.animationQueue.length * 90;\r\n            spring.update(dt);\r\n\r\n            if (spring.position >= 90) {\r\n                cube.affectedStickers = Array(cube.numOfStickers).fill(false);\r\n\r\n                cube.commitStickers();\r\n                spring.position = 0;\r\n                cube.animationQueue.shift();\r\n            }\r\n        }\r\n\r\n        const animation = cube.animationQueue[0];\r\n        let listToShow = animation ? animation.stickers : cube.stickers;\r\n\r\n        for (let i = 0; i < cube.numOfStickers; i++) {\r\n            let object = buffers[i];\r\n\r\n            const m = (animation && animation.stickersToAnimate[i])\r\n                ? glMat.rotate(\r\n                    glMat.create(),\r\n                    transformMatrix,\r\n                    spring.position * Math.PI / 180,\r\n                    animation.axis\r\n                )\r\n                : transformMatrix;\r\n\r\n            gl.uniformMatrix4fv(\r\n                programInfo.uniformLocations.transformMatrix,\r\n                false,\r\n                m,\r\n            );\r\n\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.indexBuffer);\r\n\r\n            if (showBody) {\r\n                bindPosition(object.noGapPositionBuffer, programInfo, gl);\r\n                bindColor(cube.underStickers[i].buffer, programInfo, gl);\r\n                drawElements(gl);\r\n            }\r\n\r\n            bindPosition(object.positionBuffer, programInfo, gl);\r\n            bindColor(listToShow[i].buffer, programInfo, gl);\r\n            drawElements(gl);\r\n        }\r\n\r\n        if (hintStickers) {\r\n            gl.uniformMatrix4fv(\r\n                programInfo.uniformLocations.transformMatrix,\r\n                false,\r\n                transformMatrix,\r\n            );\r\n\r\n            const drawHints = (starti, endi) => {\r\n                for (let j = starti; j < endi; j++) {\r\n                    let object = buffers[j];\r\n\r\n                    bindPosition(object.hintPositionBuffer, programInfo, gl);\r\n                    bindColor(listToShow[j].buffer, programInfo, gl);\r\n                    drawElements(gl);\r\n                }\r\n            }\r\n\r\n            if (offsetSelection === 0) {\r\n                drawHints(2 * cube.layersSq, 4 * cube.layersSq);\r\n                drawHints(5 * cube.layersSq, cube.numOfStickers);\r\n            } else if (offsetSelection === 1) {\r\n                drawHints(2 * cube.layersSq, cube.numOfStickers);\r\n            } else if (offsetSelection === 2) {\r\n                drawHints(2 * cube.layersSq, 5 * cube.layersSq);\r\n            }\r\n        }\r\n    }\r\n\r\n    requestAnimationFrame(render);\r\n}\r\n\r\nfunction renderZeroEasterEgg() {\r\n    const glDiv = document.querySelector(\"#glDiv\");\r\n    glDiv.innerHTML = `\r\n    <div style=\"display: flex; justify-content: center; align-items: center; width: 320px; height: 320px;\">\r\n        <p style=\"color: white; text-align: center;\">You can try to solve a 0-layer cube, but that's kinda boring...</p>\r\n    </div>\r\n    `;\r\n}", "export function addListenersForLeftModal() {\r\n    const drawer = document.querySelector(\".slideRight\");\r\n    let isOpen = false;\r\n\r\n    function updateDrawer(open: boolean) {\r\n        isOpen = open;\r\n        if (isOpen) {\r\n            drawer.classList.add(\"slideRightOpen\");\r\n            return;\r\n        }\r\n        drawer.classList.remove(\"slideRightOpen\");\r\n    }\r\n\r\n    document.addEventListener(\"click\", event => {\r\n        const ele = event.target as HTMLElement;\r\n\r\n        if (ele === document.querySelector(\"#menu\")) {\r\n            updateDrawer(true);\r\n            return;\r\n        }\r\n\r\n        // Close if click outside of the drawer.\r\n        if (isOpen && !ele.closest(\".slideRight\")) {\r\n            updateDrawer(false);\r\n        }\r\n    });\r\n\r\n    document.querySelector(\"#closeMenu\").addEventListener(\"click\", () => {\r\n        updateDrawer(false);\r\n    });\r\n\r\n    document.querySelector(\"#learnButton\").addEventListener(\"click\", () => {\r\n        document.location.href = \"learn.html\";\r\n    });\r\n    document.querySelector(\"#playButton\").addEventListener(\"click\", () => {\r\n        document.location.href = \"play.html\";\r\n    });\r\n    document.querySelector(\"#trainButton\").addEventListener(\"click\", () => {\r\n        document.location.href = \"train.html\";\r\n    });\r\n    document.querySelector(\"#cubleButton\").addEventListener(\"click\", () => {\r\n        document.location.href = \"cuble.html\";\r\n    });\r\n}", "import * as scene from \"./scene\";\r\nimport { addListenersForLeftModal } from \"./ui\";\r\n\r\nexport function main() {\r\n    // Initial canvas render\r\n    // scene.renderCanvas(); TODO\r\n\r\n    addListenersForLeftModal();\r\n\r\n    const moveCountEle = document.querySelector(\"#moveCount\");\r\n    let moveCount = 0;\r\n    function resetMoveCount() {\r\n        moveCount = 0;\r\n        moveCountEle.textContent = `Moves: ${moveCount}`;\r\n    }\r\n    function incrementMoveCount() {\r\n        moveCount += 1;\r\n        moveCountEle.textContent = `Moves: ${moveCount}`;\r\n    }\r\n\r\n    // Reset move count as part of page initialization.\r\n    resetMoveCount();\r\n\r\n    document.querySelector(\"#solve\").addEventListener(\"click\", (event) => {\r\n        scene.setNumLayers(3);\r\n    });\r\n\r\n    document.querySelector(\"#scramble\").addEventListener(\"click\", (event) => {\r\n        // TODO\r\n        // scene.cube.scramble();\r\n        // scene.cube.cubleScramble();\r\n\r\n        // // We want to reveal correct stickers right after scrambling.\r\n        // scene.cube.revealCorrectStickers();\r\n\r\n        // scene.render();\r\n\r\n        resetMoveCount();\r\n    });\r\n\r\n    document.addEventListener('keydown', (event) => {\r\n        // TODO\r\n        // const match = scene.cube.matchKeyToTurn(event);\r\n        // if (match) {\r\n        //     // As long as the type of turn is not a cube rotation, we want to\r\n        //     // check for correct stickers and increment move count.\r\n        //     if (match.turn) {\r\n        //         scene.cube.revealCorrectStickers();\r\n        //         incrementMoveCount();\r\n        //     }\r\n\r\n        //     scene.animateTurn();\r\n        // }\r\n    });\r\n}\r\n\r\nmain();"],
  "mappings": "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",
  "names": ["gl"]
}
