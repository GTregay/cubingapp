/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./scripts/index.ts":
/*!**************************!*\
  !*** ./scripts/index.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"main\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _scene_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scene.js */ \"./scripts/scene.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui */ \"./scripts/ui.ts\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./scripts/constants.js\");\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\n\r\n\r\n\r\nvar CENTERS = [4, 13, 22, 31, 40, 49];\r\nvar UBL = [0, 29, 36];\r\nvar URB = [6, 35, 51];\r\nvar ULF = [2, 9, 42];\r\nvar UFR = [8, 15, 45];\r\nvar DFL = [18, 11, 44];\r\nvar DRF = [24, 47, 17];\r\nvar DLB = [20, 38, 27];\r\nvar DBR = [26, 33, 53];\r\nvar UB = [3, 32];\r\nvar UL = [1, 39];\r\nvar UR = [7, 48];\r\nvar UF = [5, 12];\r\nvar FL = [10, 43];\r\nvar FR = [16, 46];\r\nvar DF = [21, 14];\r\nvar DL = [19, 41];\r\nvar DR = [25, 50];\r\nvar DB = [23, 30];\r\nvar BL = [28, 37];\r\nvar BR = [34, 52];\r\nvar speed = parseFloat(localStorage.getItem(\"#keyboardSpeed\") || _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_SPEED) * 1000;\r\n// +200 for latency\r\nvar timePerTurn = speed + 200;\r\nfunction parseMovesFromAlg(alg) {\r\n    var moves = [];\r\n    if (!alg || alg === \"\") {\r\n        moves = [];\r\n    }\r\n    else {\r\n        moves = alg.split(\" \");\r\n    }\r\n    return moves;\r\n}\r\nfunction main() {\r\n    (0,_ui__WEBPACK_IMPORTED_MODULE_1__.listenToNavButtons)();\r\n    _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.setNumOfLayers(3);\r\n    _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube[\"new\"]();\r\n    (0,_ui__WEBPACK_IMPORTED_MODULE_1__.initCanvas)();\r\n    document.addEventListener(\"keydown\", function (event) {\r\n        if (_scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.matchKeyToTurn(event.key)) {\r\n            _scene_js__WEBPACK_IMPORTED_MODULE_0__.animateTurn();\r\n        }\r\n    });\r\n    var lessonsData = [\r\n        {\r\n            \"title\": \"Intro\",\r\n            \"lessons\": [\r\n                {\r\n                    \"title\": \"About this tutorial\",\r\n                    \"setup\": \"\",\r\n                    \"algorithm\": \"D D R R D' F F L L R R U B B F F U' R R U' L F' D L D D F' U U L\",\r\n                    \"text\": \"\\n                    This section simply explains how the tutorial works. Each section will come with an animation\\n                    so you can understand what the step looks like. Use the arrow buttons above to try\\n                    the animation! We gave you a dummy example of some moves.\\n                    \",\r\n                    \"activeStickers\": [],\r\n                },\r\n                {\r\n                    \"title\": \"Centers\",\r\n                    \"setup\": \"\",\r\n                    \"algorithm\": \"x x x' x' y y y' y'\",\r\n                    \"text\": \"\\n                    In this tutorial, we will refer to different types of pieces. One of these types is\\n                    the centers, which are highlighted in the animation.\\n                    \",\r\n                    \"activeStickers\": __spreadArray([], CENTERS, true)\r\n                },\r\n                {\r\n                    \"title\": \"Corners\",\r\n                    \"setup\": \"\",\r\n                    \"algorithm\": \"x x x' x' y y y' y'\",\r\n                    \"text\": \"\\n                    Now in the animation, the corners and the centers are highlighted.\\n                    \",\r\n                    \"activeStickers\": __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], UBL, true), URB, true), ULF, true), UFR, true), DFL, true), DRF, true), DLB, true), DBR, true), CENTERS, true)\r\n                },\r\n                {\r\n                    \"title\": \"Edges\",\r\n                    \"setup\": \"\",\r\n                    \"algorithm\": \"x x x' x' y y y' y'\",\r\n                    \"text\": \"\\n                    The edges and centers are highlighted. This is the last category of piece that\\n                    you need to know for the tutorial.\\n                    \",\r\n                    \"activeStickers\": __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], UB, true), UL, true), UR, true), UF, true), FL, true), FR, true), DF, true), DL, true), DR, true), DB, true), BL, true), BR, true), CENTERS, true),\r\n                },\r\n            ],\r\n        },\r\n        {\r\n            \"title\": \"Cross\",\r\n            \"lessons\": [\r\n                {\r\n                    \"title\": \"About the cross\",\r\n                    \"setup\": \"D D R R D' F F L L R R U B B F F U' R R U' L F' D L D D F' U U L B' U U L' U U L F'\",\r\n                    \"algorithm\": \"y y y y\",\r\n                    \"text\": \"\\n                    Once you solve the cross, it should look like the animation.\\n                    You should be able to see how it forms a white cross, hence the name of the step.\\n                    Try the arrow buttons so you can see how it looks from all angles.\\n                    \",\r\n                    \"activeStickers\": __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], UB, true), UL, true), UR, true), UF, true), CENTERS, true),\r\n                },\r\n                {\r\n                    \"title\": \"Get cross piece on bottom\",\r\n                },\r\n                {\r\n                    \"title\": \"Insert cross piece\",\r\n                },\r\n            ]\r\n        },\r\n        {\r\n            \"title\": \"First layer corners\",\r\n            \"lessons\": [\r\n                {\r\n                    \"title\": \"Prepare corner to insert\",\r\n                },\r\n                {\r\n                    \"title\": \"Insert corner\",\r\n                    \"algorithm\": \"R U R' U'\",\r\n                    \"text\": \"\\n                    We only need one algorithm to insert the corners of the first layer. The key here\\n                    is knowing how to use the algorithm based on what case you are given.\\n                    \",\r\n                    \"activeStickers\": [0, 29, 36, 4, 13, 22, 31, 40, 49],\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            \"title\": \"Second layer edges\",\r\n            \"lessons\": [\r\n                {\r\n                    \"title\": \"Prepare edge to insert\"\r\n                },\r\n                {\r\n                    \"title\": \"Insert edge\"\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            \"title\": \"Last layer\",\r\n            \"lessons\": [\r\n                {\r\n                    \"title\": \"OELL\"\r\n                },\r\n                {\r\n                    \"title\": \"OCLL\"\r\n                },\r\n                {\r\n                    \"title\": \"CPLL\"\r\n                },\r\n                {\r\n                    \"title\": \"EPLL\"\r\n                }\r\n            ]\r\n        }\r\n    ];\r\n    // Array of index pairs for convenience when clicking prev or next.\r\n    var lessonIndices = [];\r\n    var currentLessonIndex = 0;\r\n    function updateLessonIndex(i) {\r\n        if (i < 0) {\r\n            return;\r\n        }\r\n        else if (i > lessonIndices.length - 1) {\r\n            return;\r\n        }\r\n        currentLessonIndex = i;\r\n        var pair = lessonIndices[i];\r\n        loadLesson(pair.i0, pair.i1);\r\n    }\r\n    var lessonNavigator = document.querySelector(\"#lessonNavigator\");\r\n    lessonsData.forEach(function (l0, i0) {\r\n        var p = document.createElement(\"p\");\r\n        p.textContent = l0.title;\r\n        p.style.fontWeight = \"bold\";\r\n        lessonNavigator.appendChild(p);\r\n        l0.lessons.forEach(function (l1, i1) {\r\n            var p = document.createElement(\"p\");\r\n            p.textContent = l1.title;\r\n            p.style.margin = \"8px 0 8px 16px\";\r\n            p.addEventListener(\"click\", function (event) {\r\n                loadLesson(i0, i1);\r\n                toggleLessonNavigator();\r\n            });\r\n            lessonNavigator.appendChild(p);\r\n            lessonIndices.push({\r\n                i0: i0,\r\n                i1: i1,\r\n            });\r\n        });\r\n    });\r\n    var alg = \"\";\r\n    var moves = [];\r\n    var moveIndex = 0;\r\n    var animationRunning = false;\r\n    var moveCounter = document.querySelector(\"#moveCounter\");\r\n    function updateMoveCounter(i) {\r\n        moveCounter.textContent = i + \" / \" + moves.length;\r\n    }\r\n    updateMoveCounter(0);\r\n    // Load the 0th index by default.\r\n    updateLessonIndex(0);\r\n    /**\r\n     *\r\n     * @param i0 Index of the lesson (eg, Cross)\r\n     * @param i1 Index of the sublesson\r\n     */\r\n    function loadLesson(i0, i1) {\r\n        var lesson = lessonsData[i0].lessons[i1];\r\n        var lessonHeader = document.querySelector(\"#lessonHeader\");\r\n        lessonHeader.textContent = lesson.title;\r\n        var lessonText = document.querySelector(\"#lessonText\");\r\n        lessonText.textContent = lesson.text;\r\n        alg = lesson.algorithm;\r\n        moves = parseMovesFromAlg(alg);\r\n        moveIndex = 0;\r\n        for (var i = moves.length - 1; i >= 0; i--) {\r\n            takeStepInAlgorithm(moves[i], false);\r\n        }\r\n        updateMoveCounter(0);\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.setActiveStickers(lesson.activeStickers);\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.setNumOfLayers(3);\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube[\"new\"]();\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.buffers.initBufferData(_scene_js__WEBPACK_IMPORTED_MODULE_0__.cube);\r\n        var setup = lesson.setup;\r\n        var setupMoves = parseMovesFromAlg(setup);\r\n        setupMoves.forEach(function (move) {\r\n            takeStepInAlgorithm(move, true);\r\n        });\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.setStickers();\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.render();\r\n    }\r\n    var startStopAnimation = document.querySelector(\"#startStopAnimation\");\r\n    function toggleStartStop() {\r\n        animationRunning = !animationRunning;\r\n        if (animationRunning) {\r\n            startStopAnimation.textContent = \"Pause\";\r\n            recursiveTurn();\r\n        }\r\n        else {\r\n            startStopAnimation.textContent = \"Start\";\r\n        }\r\n    }\r\n    startStopAnimation.addEventListener(\"click\", function (event) {\r\n        toggleStartStop();\r\n    });\r\n    function recursiveTurn() {\r\n        takeStepInAlgorithm(moves[moveIndex], true);\r\n        moveIndex++;\r\n        updateMoveCounter(moveIndex);\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.animateTurn(function () {\r\n            if (moveIndex < moves.length && animationRunning) {\r\n                recursiveTurn();\r\n            }\r\n            else {\r\n                toggleStartStop();\r\n            }\r\n        });\r\n    }\r\n    document.querySelector(\"#leftButton\").addEventListener(\"click\", function (event) {\r\n        if (moveIndex > 0) {\r\n            moveIndex--;\r\n            takeStepInAlgorithm(moves[moveIndex], false);\r\n            _scene_js__WEBPACK_IMPORTED_MODULE_0__.animateTurn();\r\n            updateMoveCounter(moveIndex);\r\n        }\r\n    });\r\n    document.querySelector(\"#rightButton\").addEventListener(\"click\", function (event) {\r\n        if (moveIndex < moves.length) {\r\n            takeStepInAlgorithm(moves[moveIndex], true);\r\n            _scene_js__WEBPACK_IMPORTED_MODULE_0__.animateTurn();\r\n            moveIndex++;\r\n            updateMoveCounter(moveIndex);\r\n        }\r\n    });\r\n    function toggleLessonNavigator() {\r\n        lessonNavigator.classList.toggle(\"slideUpOpen\");\r\n    }\r\n    document.querySelector(\"#openClose\").addEventListener(\"click\", function (event) {\r\n        toggleLessonNavigator();\r\n    });\r\n    document.querySelector(\"#prevLesson\").addEventListener(\"click\", function () {\r\n        updateLessonIndex(currentLessonIndex - 1);\r\n    });\r\n    document.querySelector(\"#nextLesson\").addEventListener(\"click\", function () {\r\n        updateLessonIndex(currentLessonIndex + 1);\r\n    });\r\n    function takeStepInAlgorithm(move, forward) {\r\n        switch (move) {\r\n            case \"x\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.cubeRotate(0, forward);\r\n                break;\r\n            case \"x'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.cubeRotate(0, !forward);\r\n                break;\r\n            case \"y\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.cubeRotate(1, forward);\r\n                break;\r\n            case \"y'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.cubeRotate(1, !forward);\r\n                break;\r\n            case \"z\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.cubeRotate(2, forward);\r\n                break;\r\n            case \"z'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.cubeRotate(2, !forward);\r\n                break;\r\n            case \"U\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(1, 0, forward);\r\n                break;\r\n            case \"U'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(1, 0, !forward);\r\n                break;\r\n            case \"D\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(1, 2, !forward);\r\n                break;\r\n            case \"D'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(1, 2, forward);\r\n                break;\r\n            case \"F\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(2, 0, forward);\r\n                break;\r\n            case \"F'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(2, 0, !forward);\r\n                break;\r\n            case \"B\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(2, 2, !forward);\r\n                break;\r\n            case \"B'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(2, 2, forward);\r\n                break;\r\n            case \"L\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(0, 2, !forward);\r\n                break;\r\n            case \"L'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(0, 2, forward);\r\n                break;\r\n            case \"R\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(0, 0, forward);\r\n                break;\r\n            case \"R'\":\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.turn(0, 0, !forward);\r\n                break;\r\n            default:\r\n                throw new Error(\"Invalid turn in algorithm: \" + move);\r\n        }\r\n    }\r\n}\r\nmain();\r\n\n\n//# sourceURL=webpack://rubiks-cube/./scripts/index.ts?");

/***/ }),

/***/ "./scripts/ui.ts":
/*!***********************!*\
  !*** ./scripts/ui.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"listenToNavButtons\": () => (/* binding */ listenToNavButtons),\n/* harmony export */   \"initCanvas\": () => (/* binding */ initCanvas)\n/* harmony export */ });\n/* harmony import */ var _scene_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scene.js */ \"./scripts/scene.js\");\n/* harmony import */ var _pickId_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pickId.js */ \"./scripts/pickId.js\");\n\r\n\r\nfunction listenToNavButtons() {\r\n    document.querySelector(\"#learnButton\").addEventListener(\"click\", function () {\r\n        document.location = \"index.html\";\r\n    });\r\n    document.querySelector(\"#playButton\").addEventListener(\"click\", function () {\r\n        document.location = \"play.html\";\r\n    });\r\n    document.querySelector(\"#settingsButton\").addEventListener(\"click\", function () {\r\n        document.location = \"settings.html\";\r\n    });\r\n}\r\nvar canvas = document.querySelector('#glCanvas');\r\nvar gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\nfunction posRelativeToCanvas(x, y) {\r\n    var rect = canvas.getBoundingClientRect();\r\n    return {\r\n        x: x - rect.left,\r\n        y: y - rect.top,\r\n    };\r\n}\r\nfunction initCanvas() {\r\n    _scene_js__WEBPACK_IMPORTED_MODULE_0__.buffers.initBufferData(_scene_js__WEBPACK_IMPORTED_MODULE_0__.cube);\r\n    _scene_js__WEBPACK_IMPORTED_MODULE_0__.initScene();\r\n    function pointerDown(x, y) {\r\n        var pos = posRelativeToCanvas(x, y);\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.onPointerDown(pos.x, pos.y);\r\n        // Redraw in order to read the pixels under the pointer coordinates\r\n        // that were just set.\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.render();\r\n    }\r\n    function pointerMove(x, y) {\r\n        var pos = posRelativeToCanvas(x, y);\r\n        _scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.onPointerMove(pos.x, pos.y);\r\n    }\r\n    function pointerUp() {\r\n        var id = (0,_pickId_js__WEBPACK_IMPORTED_MODULE_1__.idFromColor)(_scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.pixels);\r\n        if (_scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.getNumOfMouseMoves() > 2) {\r\n            if (id == Math.pow(256, 4) - 1) {\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.doCubeRotateFromMouseDrag(_scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.mouseXOnDown, _scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.mouseYOnDown, _scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.getDx(), _scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.getDy());\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.animateTurn();\r\n            }\r\n            else {\r\n                var dx = _scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.getDx();\r\n                var dy = _scene_js__WEBPACK_IMPORTED_MODULE_0__.dragDetector.getDy();\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.cube.doTurnFromMouseDrag(id, dx, dy);\r\n                _scene_js__WEBPACK_IMPORTED_MODULE_0__.animateTurn();\r\n            }\r\n        }\r\n    }\r\n    gl.canvas.addEventListener('touchstart', function (event) {\r\n        var touch = event.touches[0];\r\n        pointerDown(touch.pageX, touch.pageY);\r\n    });\r\n    gl.canvas.addEventListener('touchmove', function (event) {\r\n        var touch = event.touches[0];\r\n        pointerMove(touch.pageX, touch.pageY);\r\n    });\r\n    gl.canvas.addEventListener('touchend', function () {\r\n        pointerUp();\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://rubiks-cube/./scripts/ui.ts?");

/***/ }),

/***/ "./scripts/buffers.js":
/*!****************************!*\
  !*** ./scripts/buffers.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Buffers\": () => (/* binding */ Buffers)\n/* harmony export */ });\n/* harmony import */ var _pickId_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pickId.js */ \"./scripts/pickId.js\");\n\r\n\r\nconst canvas = document.querySelector('#glCanvas');\r\nconst gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n\r\nclass Buffers {\r\n\r\n    initBufferData(cube) {\r\n        this.cube = cube;\r\n\r\n        // Vertex positions with gap.\r\n        this.gap = 0.03;\r\n        let allPositions = this._concatPositions();\r\n\r\n        // Vertex positions with no gap so user can drag between the gaps.\r\n        this.gap = 0.0;\r\n        let allNoGapPositions = this._concatPositions();\r\n\r\n        let allPickingColors = [];\r\n        for (let i = 0; i < this.cube.numOfStickers; i++) {\r\n            const c = (0,_pickId_js__WEBPACK_IMPORTED_MODULE_0__.colorFromId)(i);\r\n            for (let j = 0; j < 4; j++) {\r\n                allPickingColors.push(c[0], c[1], c[2], c[3]);\r\n            }\r\n        }\r\n\r\n        this.objects = [];\r\n        for (let i = 0; i < this.cube.numOfStickers; i++) {\r\n            let object = {}\r\n\r\n            let positions = [];\r\n            let noGapPositions = [];\r\n            for (let j = 0; j < 12; j++) {\r\n                let index = i * 12 + j;\r\n                positions.push(allPositions[index]);\r\n                noGapPositions.push(allNoGapPositions[index]);\r\n            }\r\n\r\n            object.positionBuffer = gl.createBuffer();\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, object.positionBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n            object.noGapPositionBuffer = gl.createBuffer();\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, object.noGapPositionBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(noGapPositions), gl.STATIC_DRAW);\r\n\r\n            // Define each face as two triangles.\r\n            // Given vertices A, B, C, and D, we define triangles ABC and ACD.\r\n            let indices = [];\r\n            indices.push(0, 1, 2, 0, 2, 3);\r\n\r\n            object.indexBuffer = gl.createBuffer();\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.indexBuffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n            this.objects.push(object);\r\n        }\r\n\r\n        for (let i = 0; i < this.cube.layersSq * 2; i++) {\r\n            let object = this.objects[i];\r\n\r\n            let pickingColors = [];\r\n            for (let j = 0; j < 16; j++) {\r\n                let index = i * 16 + j;\r\n                pickingColors.push(allPickingColors[index]);\r\n            }\r\n\r\n            object.pickingColorBuffer = gl.createBuffer();\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, object.pickingColorBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pickingColors), gl.STATIC_DRAW);\r\n        }\r\n    }\r\n\r\n    _concatPositions() {\r\n        let positions = [];\r\n        // Top face\r\n        positions = positions.concat(this._topFace(1, 1.0));\r\n        // Front face\r\n        positions = positions.concat(this._frontFace(0, 1.0));\r\n        // Bottom face\r\n        positions = positions.concat(this._bottomFace(1, -1.0));\r\n        // Back face\r\n        positions = positions.concat(this._backFace(0, -1.0));\r\n        // Left face\r\n        positions = positions.concat(this._leftFace(2, -1.0));\r\n        // Right face\r\n        positions = positions.concat(this._rightFace(2, 1.0));\r\n        return positions;\r\n    }\r\n\r\n    // Notes for face functions\r\n    //\r\n    // 0 3 6\r\n    // 1 4 7\r\n    // 2 5 8\r\n    //\r\n    // a (axis): 0, 1, or 2\r\n    // n (negative): -1.0 or 1.0\r\n\r\n    _topFace(a, n) {\r\n        let coords = [];\r\n\r\n        if (this.cube.layersEven) {\r\n            for (let i = 0; i < this.cube.numOfLayers; i++) {\r\n                for (let j = 0; j < this.cube.numOfLayers; j++) {\r\n                    const a = -1 + 1 / this.cube.numOfLayers + j * 2 / this.cube.numOfLayers;\r\n                    const b = -1 + 1 / this.cube.numOfLayers + i * 2 / this.cube.numOfLayers;\r\n                    coords.push([a, b, n]);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = -this.cube.layersHalf; i <= this.cube.layersHalf; i++) {\r\n                for (let j = -this.cube.layersHalf; j <= this.cube.layersHalf; j++) {\r\n                    coords.push([2.0 * j / this.cube.numOfLayers, 2.0 * i / this.cube.numOfLayers, n]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._concatStickers(coords, a);\r\n    }\r\n\r\n    _frontFace(a, n) {\r\n        let coords = [];\r\n\r\n        if (this.cube.layersEven) {\r\n            for (let i = 0; i < this.cube.numOfLayers; i++) {\r\n                for (let j = this.cube.numOfLayers - 1; j >= 0; j--) {\r\n                    const a = -1 + 1 / this.cube.numOfLayers + i * 2 / this.cube.numOfLayers;\r\n                    const b = -1 + 1 / this.cube.numOfLayers + j * 2 / this.cube.numOfLayers;\r\n                    coords.push([a, b, n]);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = -this.cube.layersHalf; i <= this.cube.layersHalf; i++) {\r\n                for (let j = this.cube.layersHalf; j >= -this.cube.layersHalf; j--) {\r\n                    coords.push([2.0 * i / this.cube.numOfLayers, 2.0 * j / this.cube.numOfLayers, n]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._concatStickers(coords, a);\r\n    }\r\n\r\n    _bottomFace(a, n) {\r\n        let coords = [];\r\n\r\n        if (this.cube.layersEven) {\r\n            for (let i = 0; i < this.cube.numOfLayers; i++) {\r\n                for (let j = this.cube.numOfLayers - 1; j >= 0; j--) {\r\n                    const a = -1 + 1 / this.cube.numOfLayers + j * 2 / this.cube.numOfLayers;\r\n                    const b = -1 + 1 / this.cube.numOfLayers + i * 2 / this.cube.numOfLayers;\r\n                    coords.push([a, b, n]);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = -this.cube.layersHalf; i <= this.cube.layersHalf; i++) {\r\n                for (let j = this.cube.layersHalf; j >= -this.cube.layersHalf; j--) {\r\n                    coords.push([2.0 * j / this.cube.numOfLayers, 2.0 * i / this.cube.numOfLayers, n]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._concatStickers(coords, a);\r\n    }\r\n\r\n    _backFace(a, n) {\r\n        let coords = [];\r\n\r\n        if (this.cube.layersEven) {\r\n            for (let i = 0; i < this.cube.numOfLayers; i++) {\r\n                for (let j = 0; j < this.cube.numOfLayers; j++) {\r\n                    const a = -1 + 1 / this.cube.numOfLayers + i * 2 / this.cube.numOfLayers;\r\n                    const b = -1 + 1 / this.cube.numOfLayers + j * 2 / this.cube.numOfLayers;\r\n                    coords.push([a, b, n]);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = -this.cube.layersHalf; i <= this.cube.layersHalf; i++) {\r\n                for (let j = -this.cube.layersHalf; j <= this.cube.layersHalf; j++) {\r\n                    coords.push([2.0 * i / this.cube.numOfLayers, 2.0 * j / this.cube.numOfLayers, n]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._concatStickers(coords, a);\r\n    }\r\n\r\n    _leftFace(a, n) {\r\n        let coords = [];\r\n\r\n        if (this.cube.layersEven) {\r\n            for (let i = 0; i < this.cube.numOfLayers; i++) {\r\n                for (let j = this.cube.numOfLayers - 1; j >= 0; j--) {\r\n                    const a = -1 + 1 / this.cube.numOfLayers + j * 2 / this.cube.numOfLayers;\r\n                    const b = -1 + 1 / this.cube.numOfLayers + i * 2 / this.cube.numOfLayers;\r\n                    coords.push([a, b, n]);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = -this.cube.layersHalf; i <= this.cube.layersHalf; i++) {\r\n                for (let j = this.cube.layersHalf; j >= -this.cube.layersHalf; j--) {\r\n                    coords.push([2.0 * j / this.cube.numOfLayers, 2.0 * i / this.cube.numOfLayers, n]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._concatStickers(coords, a);\r\n    }\r\n\r\n    _rightFace(a, n) {\r\n        let coords = [];\r\n\r\n        if (this.cube.layersEven) {\r\n            for (let i = this.cube.numOfLayers - 1; i >= 0; i--) {\r\n                for (let j = this.cube.numOfLayers - 1; j >= 0; j--) {\r\n                    const a = -1 + 1 / this.cube.numOfLayers + j * 2 / this.cube.numOfLayers;\r\n                    const b = -1 + 1 / this.cube.numOfLayers + i * 2 / this.cube.numOfLayers;\r\n                    coords.push([a, b, n]);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = this.cube.layersHalf; i >= -this.cube.layersHalf; i--) {\r\n                for (let j = this.cube.layersHalf; j >= -this.cube.layersHalf; j--) {\r\n                    coords.push([2.0 * j / this.cube.numOfLayers, 2.0 * i / this.cube.numOfLayers, n]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._concatStickers(coords, a);\r\n    }\r\n\r\n    _concatStickers(coords, a) {\r\n        let out = [];\r\n        for (let i = 0; i < this.cube.layersSq; i++) {\r\n            const temp = coords[i];\r\n            out = out.concat(this._sticker(a, temp[0], temp[1], temp[2]));\r\n        }\r\n        return out;\r\n    }\r\n\r\n    _sticker(a, x, y, n) {\r\n        // size\r\n        const s = (1.0 / this.cube.numOfLayers) - this.gap;\r\n\r\n        const coords = [\r\n            [x - s, y - s, n],\r\n            [x + s, y - s, n],\r\n            [x + s, y + s, n],\r\n            [x - s, y + s, n],\r\n        ];\r\n\r\n        let out = [];\r\n\r\n        const numOfVerticesInSquare = 4;\r\n        const numOfDimensions = 3;\r\n\r\n        for (let i = 0; i < numOfVerticesInSquare; i++) {\r\n            const temp = coords[i];\r\n            let appendage = [];\r\n            for (let i = 0; i < numOfDimensions; i++) {\r\n                appendage.push(temp[(a + i) % 3]);\r\n            }\r\n            out = out.concat(appendage);\r\n        }\r\n        return out;\r\n    }\r\n}\n\n//# sourceURL=webpack://rubiks-cube/./scripts/buffers.js?");

/***/ }),

/***/ "./scripts/constants.js":
/*!******************************!*\
  !*** ./scripts/constants.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_SPEED\": () => (/* binding */ DEFAULT_SPEED)\n/* harmony export */ });\nconst DEFAULT_SPEED = \"0.3\";\n\n//# sourceURL=webpack://rubiks-cube/./scripts/constants.js?");

/***/ }),

/***/ "./scripts/cube.js":
/*!*************************!*\
  !*** ./scripts/cube.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubeLogic\": () => (/* binding */ CubeLogic)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./scripts/constants.js\");\n\r\n\r\nconst canvas = document.querySelector('#glCanvas');\r\nconst gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n\r\nconst WHITE = {\r\n    active: [1.0, 1.0, 1.0, 1.0],\r\n    inactive: [0.5, 0.5, 0.5, 1.0],\r\n}\r\nconst YELLOW = {\r\n    active: [1.0, 1.0, 0.0, 1.0],\r\n    inactive: [0.5, 0.5, 0.0, 1.0],\r\n}\r\nconst GREEN = {\r\n    active: [0.0, 1.0, 0.0, 1.0],\r\n    inactive: [0.0, 0.5, 0.0, 1.0],\r\n}\r\nconst BLUE = {\r\n    active: [0.0, 0.0, 1.0, 1.0],\r\n    inactive: [0.0, 0.0, 0.5, 1.0],\r\n}\r\nconst ORANGE = {\r\n    active: [1.0, 0.5, 0.0, 1.0],\r\n    inactive: [0.5, 0.25, 0.0, 1.0],\r\n}\r\nconst RED = {\r\n    active: [1.0, 0.0, 0.0, 0.5],\r\n    inactive: [0.5, 0.0, 0.0, 1.0],\r\n}\r\n\r\nconst turnTypes = {\r\n    KEYBOARD: 0,\r\n    DRAG: 1,\r\n}\r\n\r\nfunction repeatColorFor4Vertices(color, activeStickers, sticker) {\r\n    let rgba = activeStickers.includes(sticker) ? color.active : color.inactive;\r\n    \r\n    let arr = [];\r\n    for (let i = 0; i < 4; i++) {\r\n        arr.push(rgba[0], rgba[1], rgba[2], rgba[3]);\r\n    }\r\n\r\n    const buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);\r\n\r\n    return buffer;\r\n}\r\n\r\nfunction pushN(cube, color, face) {\r\n    for (let i = 0; i < cube.layersSq; i++) {\r\n        cube.stickers.push(repeatColorFor4Vertices(color, cube.activeStickers, face + i));\r\n    }\r\n}\r\n\r\nclass CubeLogic {\r\n    constructor() {\r\n        const keyboardSpeed = localStorage.getItem(\"#keyboardSpeed\") || _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SPEED;\r\n        const dragSpeed = localStorage.getItem(\"#dragSpeed\") || _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SPEED;\r\n\r\n        this.keyboardSpeedFactor = keyboardSpeed * 1000 / (Math.PI / 2);\r\n        this.dragSpeedFactor = dragSpeed * 1000 / (Math.PI / 2);\r\n\r\n        // The factor should be set each time you start a new turn type, whether it be keyboard or drag.\r\n        // This is because the different turn types may be a different speed.\r\n        this.factor = this.keyboardSpeedFactor;\r\n    }\r\n\r\n    new() {\r\n        this.axis = 0;\r\n\r\n        if (!this.activeStickers) {\r\n            this.activeStickers = [];\r\n        }\r\n\r\n        this.stickers = [];\r\n        console.log(this.activeStickers);\r\n        pushN(this, WHITE, 0);\r\n        pushN(this, GREEN, 9);\r\n        pushN(this, YELLOW, 18);\r\n        pushN(this, BLUE, 27);\r\n        pushN(this, ORANGE, 36);\r\n        pushN(this, RED, 45);\r\n        this.resetAffectedStickers();\r\n        this.setStickers();\r\n    }\r\n\r\n    naiveScramble() {\r\n        let numTurns = this.numOfLayers * this.numOfLayers * 10;\r\n        for (let i = 0; i < numTurns; i++) {\r\n            let axis = Math.floor(Math.random() * 3);\r\n            let layer = Math.floor(Math.random() * this.numOfLayers);\r\n            let clockwise = Math.floor(Math.random() * 1) == 0.0;\r\n            this._matchTurn(axis, layer, clockwise);\r\n        }\r\n\r\n        this.setStickers();\r\n    }\r\n\r\n    setNumOfLayers(num) {\r\n        this.numOfLayers = parseInt(num);\r\n        this.layersSq = this.numOfLayers * this.numOfLayers;\r\n        this.layersHalf = parseInt(this.numOfLayers / 2);\r\n        this.layersEven = this.numOfLayers % 2 == 0;\r\n        this.numOfStickers = this.layersSq * 6;\r\n    }\r\n\r\n    getStickers() {\r\n        return this.currentStickers;\r\n    }\r\n\r\n    setStickers() {\r\n        this.currentStickers = [...this.stickers];\r\n    }\r\n\r\n    getAffectedStickers() {\r\n        return this.affectedStickers;\r\n    }\r\n\r\n    resetAffectedStickers() {\r\n        let numOfStickers = this.numOfLayers * this.numOfLayers * 6;\r\n        this.affectedStickers = [];\r\n        for (let i = 0; i < numOfStickers; i++) {\r\n            this.affectedStickers.push(false);\r\n        }\r\n    }\r\n\r\n    setActiveStickers(arr) {\r\n        this.activeStickers = arr;\r\n    }\r\n\r\n    activateAllStickers() {\r\n        this.activeStickers = [];\r\n        for (let i = 0; i < this.numOfStickers; i++) {\r\n            this.activeStickers.push(i);\r\n        }\r\n    }\r\n\r\n    turn(axis, layer, clockwise) {\r\n        this.axis = axis;\r\n        this.clockwise = clockwise;\r\n        \r\n        this.resetAffectedStickers();\r\n\r\n        this._matchTurn(axis, layer, clockwise);\r\n    }\r\n\r\n    sliceTurn(axis, clockwise) {\r\n        this.axis = axis;\r\n        this.clockwise = clockwise;\r\n\r\n        this.resetAffectedStickers();\r\n\r\n        for (let i = 1; i < this.numOfLayers - 1; i++) {\r\n            this._matchTurn(axis, i, clockwise);\r\n        }\r\n    }\r\n\r\n    wideTurn(axis, layer, clockwise) {\r\n        this.axis = axis;\r\n        this.clockwise = clockwise;\r\n\r\n        this.resetAffectedStickers();\r\n\r\n        this._matchTurn(axis, layer, clockwise);\r\n        for (let i = 1; i < this.numOfLayers - 1; i++) {\r\n            this._matchTurn(axis, i, clockwise);\r\n        }\r\n\r\n    }\r\n\r\n    cubeRotate(axis, clockwise) {\r\n        this.axis = axis;\r\n        this.clockwise = clockwise;\r\n\r\n        this.resetAffectedStickers();\r\n\r\n        for (let i = 0; i < this.numOfLayers; i++) {\r\n            this._matchTurn(axis, i, clockwise);\r\n        }\r\n    }\r\n\r\n    _matchTurn(axis, layer, clockwise) {\r\n        if (axis == 0) {\r\n            this._turnXAxis(layer, clockwise);\r\n            if (layer == 0) {\r\n                this._turnOuter(5, clockwise);\r\n            } else if (layer == this.numOfLayers - 1) {\r\n                this._turnOuter(4, !clockwise);\r\n            }\r\n        } else if (axis == 1) {\r\n            this._turnYAxis(layer, clockwise);\r\n            if (layer == 0) {\r\n                this._turnOuter(0, clockwise);\r\n            } else if (layer == this.numOfLayers - 1) {\r\n                this._turnOuter(2, !clockwise);\r\n            }\r\n        } else if (axis == 2) {\r\n            this._turnZAxis(layer, clockwise);\r\n            if (layer == 0) {\r\n                this._turnOuter(1, clockwise);\r\n            } else if (layer == this.numOfLayers - 1) {\r\n                this._turnOuter(3, !clockwise);\r\n            }\r\n        } else {\r\n            console.error(`Axis ${axis} not recognized`);\r\n        }\r\n    }\r\n\r\n    _turnXAxis(layer, clockwise) {\r\n        let layersSq = this.numOfLayers * this.numOfLayers;\r\n        for (let i = 1; i <= this.numOfLayers; i++) {\r\n            this._cycle(\r\n                clockwise,\r\n                0 * layersSq + layersSq - i - layer * this.numOfLayers,\r\n                3 * layersSq + layersSq - i - layer * this.numOfLayers,\r\n                2 * layersSq + layersSq - i - layer * this.numOfLayers,\r\n                1 * layersSq + layersSq - i - layer * this.numOfLayers,\r\n            );\r\n        }\r\n    }\r\n\r\n    _turnYAxis(layer, clockwise) {\r\n        let layersSq = this.numOfLayers * this.numOfLayers;\r\n        for (let i = 0; i < this.numOfLayers; i++) {\r\n            this._cycle(\r\n                clockwise,\r\n                1 * layersSq + i * this.numOfLayers + layer,\r\n                4 * layersSq + i * this.numOfLayers + layer,\r\n                3 * layersSq + (this.numOfLayers - i - 1) * this.numOfLayers + (this.numOfLayers - 1) - layer,\r\n                5 * layersSq + i * this.numOfLayers + layer,\r\n            );\r\n        }\r\n    }\r\n\r\n    _turnZAxis(layer, clockwise) {\r\n        let layersSq = this.numOfLayers * this.numOfLayers;\r\n        for (let i = 0; i < this.numOfLayers; i++) {\r\n            this._cycle(\r\n                clockwise,\r\n                0 * layersSq + (i + 1) * this.numOfLayers - 1 - layer,\r\n                5 * layersSq + i + this.numOfLayers * layer,\r\n                2 * layersSq + (this.numOfLayers - i - 1) * this.numOfLayers + layer,\r\n                4 * layersSq + layersSq - (i + 1) - layer * this.numOfLayers,\r\n            );\r\n        }\r\n    }\r\n\r\n    _turnOuter(face, clockwise) {\r\n        let offset = face * this.numOfLayers * this.numOfLayers;\r\n\r\n        if (this.numOfLayers % 2 != 0) {\r\n            let center = offset + Math.floor(this.numOfLayers * this.numOfLayers / 2);\r\n            this.affectedStickers[center] = true;\r\n        }\r\n\r\n        for (let i = 0; i < Math.floor(this.numOfLayers / 2); i++) {\r\n            // corners\r\n            let top_l = offset + (this.numOfLayers + 1) * i;\r\n            let top_r = offset + (this.numOfLayers - 1) * (this.numOfLayers - i);\r\n            let bot_r = offset + (this.numOfLayers + 1) * (this.numOfLayers - i - 1);\r\n            let bot_l = offset + (this.numOfLayers - 1) * (i + 1);\r\n\r\n            this._cycle(clockwise, top_l, top_r, bot_r, bot_l);\r\n\r\n            // edges\r\n            let numOfEdges = this.numOfLayers - 2 * (i + 1);\r\n            for (let j = 0; j < numOfEdges; j++) {\r\n                this._cycle(\r\n                    clockwise,\r\n                    top_l + this.numOfLayers * (j + 1),\r\n                    top_r + j + 1,\r\n                    bot_l + this.numOfLayers * (numOfEdges - j),\r\n                    top_l + (numOfEdges - j),\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    _cycle(clockwise, i1, i2, i3, i4) {\r\n        this.affectedStickers[i1] = true;\r\n        this.affectedStickers[i2] = true;\r\n        this.affectedStickers[i3] = true;\r\n        this.affectedStickers[i4] = true;\r\n\r\n        if (clockwise) {\r\n            this._cycleHelper(i1, i2, i3, i4);\r\n        } else {\r\n            this._cycleHelper(i4, i3, i2, i1);\r\n        }\r\n    }\r\n\r\n    _cycleHelper(i1, i2, i3, i4) {\r\n        let temp = this.stickers[i4];\r\n        this.stickers[i4] = this.stickers[i3];\r\n        this.stickers[i3] = this.stickers[i2];\r\n        this.stickers[i2] = this.stickers[i1];\r\n        this.stickers[i1] = temp;\r\n    }\r\n\r\n    matchKeyToTurn(key) {\r\n        this.turnType = turnTypes.KEYBOARD;\r\n        this.factor = this.keyboardSpeedFactor;\r\n\r\n        switch (key) {\r\n            case \"n\": // x\r\n                this.cubeRotate(0, true);\r\n                return true;\r\n            case \"b\": // x'\r\n                this.cubeRotate(0, false);\r\n                return true;\r\n            case \";\": // y\r\n                this.cubeRotate(1, true);\r\n                return true;\r\n            case \"a\": // y'\r\n                this.cubeRotate(1, false);\r\n                return true;\r\n            case \"p\": // z\r\n                this.cubeRotate(2, true);\r\n                return true;\r\n            case \"q\": // z'\r\n                this.cubeRotate(2, false);\r\n                return true;\r\n            case \"j\": // U\r\n                this.turn(1, 0, true);\r\n                return true;\r\n            case \"f\": // U'\r\n                this.turn(1, 0, false);\r\n                return true;\r\n            case \"s\": // D\r\n                this.turn(1, this.numOfLayers - 1, false);\r\n                return true;\r\n            case \"l\": // D'\r\n                this.turn(1, this.numOfLayers - 1, true);\r\n                return true;\r\n            case \"h\": // F\r\n                this.turn(2, 0, true);\r\n                return true;\r\n            case \"g\": // F'\r\n                this.turn(2, 0, false);\r\n                return true;\r\n            case \"w\": // B\r\n                this.turn(2, this.numOfLayers - 1, false);\r\n                return true;\r\n            case \"o\": // B'\r\n                this.turn(2, this.numOfLayers - 1, true);\r\n                return true;\r\n            case \"d\": // L\r\n                this.turn(0, this.numOfLayers - 1, false);\r\n                return true;\r\n            case \"e\": // L'\r\n                this.turn(0, this.numOfLayers - 1, true);\r\n                return true;\r\n            case \"i\": // R\r\n                this.turn(0, 0, true);\r\n                return true;\r\n            case \"k\": // R'\r\n                this.turn(0, 0, false);\r\n                return true;\r\n            case \"[\": // M\r\n                this.sliceTurn(0, false);\r\n                return true;\r\n            case \"'\": // M'\r\n                this.sliceTurn(0, true);\r\n                return true;\r\n            case \"c\": // E\r\n                this.sliceTurn(1, false);\r\n                return true;\r\n            case \",\": // E'\r\n                this.sliceTurn(1, true);\r\n                return true;\r\n            case \"y\": // S\r\n                this.sliceTurn(2, true);\r\n                return true;\r\n            case \"t\": // S'\r\n                this.sliceTurn(2, false);\r\n                return true;\r\n            case \"u\": // r\r\n                this.wideTurn(0, 0, true);\r\n                return true;\r\n            case \"m\": // r'\r\n                this.wideTurn(0, 0, false);\r\n                return true;\r\n            case \"v\": // l\r\n                this.wideTurn(0, this.numOfLayers - 1, false);\r\n                return true;\r\n            case \"r\": // l'\r\n                this.wideTurn(0, this.numOfLayers - 1, true);\r\n                return true;\r\n        }\r\n    }\r\n\r\n    doTurnFromMouseDrag(id, dx, dy) {\r\n        this.turnType = turnTypes.DRAG;\r\n        this.factor = this.dragSpeedFactor;\r\n\r\n        const ratio = dy / dx;\r\n        const ratioThreshold = 0.55;\r\n        if (id < this.layersSq) {\r\n            if (ratio < -ratioThreshold || ratio > ratioThreshold) {\r\n                this.turn(0, this.numOfLayers - 1 - parseInt(id / 3), dy < 0);\r\n            } else {\r\n                this.turn(2, this.numOfLayers - 1 - (id % 3), dx > 0);\r\n            }\r\n        } else if (id >= this.layersSq) {\r\n            if (ratio < -ratioThreshold || ratio > ratioThreshold) {\r\n                this.turn(0, this.numOfLayers - 1 - parseInt((id - this.layersSq) / 3), dy < 0);\r\n            } else {\r\n                this.turn(1, (id - this.layersSq) % 3, dx < 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    doCubeRotateFromMouseDrag(x, y, dx, dy) {\r\n        this.turnType = turnTypes.DRAG;\r\n        this.factor = this.dragSpeedFactor;\r\n\r\n        // console.log(x, y, dx, dy);\r\n\r\n        // top center\r\n        if (y < 62 && x > 88 && x < 226) {\r\n            console.log(\"top center\");\r\n            this.cubeRotate(0, dy < 0);\r\n        }\r\n\r\n        // bottom center\r\n        else if (y > 260 && x > 88 && x < 226) {\r\n            console.log(\"bottom center\");\r\n            this.cubeRotate(0, dy < 0);\r\n        }\r\n\r\n        // top left\r\n        else if (x < 88 && y > 62 && y < 145) {\r\n            console.log(\"top left\");\r\n            this.cubeRotate(2, dx > 0);\r\n        }\r\n\r\n        // top right\r\n        else if (x > 226 && y > 62 && y < 145) {\r\n            console.log(\"top right\");\r\n            this.cubeRotate(2, dx > 0);\r\n        }\r\n\r\n        // bottom left\r\n        else if (x < 88 && y > 145 && y < 260) {\r\n            console.log(\"bottom left\");\r\n            this.cubeRotate(1, dx < 0);\r\n        }\r\n\r\n        // bottom right\r\n        else if (x > 226 && y > 145 && y < 260) {\r\n            console.log(\"bottom right\");\r\n            this.cubeRotate(1, dx < 0);\r\n        }\r\n    }\r\n\r\n    doCubeRotateFromButton(axis, clockwise) {\r\n        this.turnType = turnTypes.DRAG;\r\n        this.factor = this.dragSpeedFactor;\r\n\r\n        this.cubeRotate(axis, clockwise);\r\n    }\r\n}\n\n//# sourceURL=webpack://rubiks-cube/./scripts/cube.js?");

/***/ }),

/***/ "./scripts/dragDetector.js":
/*!*********************************!*\
  !*** ./scripts/dragDetector.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DragDetector\": () => (/* binding */ DragDetector)\n/* harmony export */ });\nconst canvas = document.querySelector('#glCanvas');\r\nconst gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n\r\nclass DragDetector {\r\n    constructor() {\r\n        this.mouseX = -1;\r\n        this.mouseY = -1;\r\n        this.mouseXOnDown = -1;\r\n        this.mouseYOnDown = -1;\r\n        this.pixelX = -1;\r\n        this.pixelY = -1;\r\n        this.pixels = new Uint8Array(4);\r\n        this.pixelsOnDown;\r\n        this.numOfMouseMoves = 0;\r\n    }\r\n\r\n    getNumOfMouseMoves() {\r\n        return this.numOfMouseMoves;\r\n    }\r\n\r\n    onPointerDown(x, y) {\r\n        this.mouseXOnDown = x;\r\n        this.mouseYOnDown = y;\r\n        this.pixelX = x * gl.canvas.width / gl.canvas.clientWidth;\r\n        this.pixelY = gl.canvas.height - y * gl.canvas.height / gl.canvas.clientHeight - 1;\r\n\r\n        this.numOfMouseMoves = 0;\r\n    }\r\n\r\n    onPointerMove(x, y) {\r\n        this.mouseX = x;\r\n        this.mouseY = y;\r\n        this.numOfMouseMoves++;\r\n    }\r\n\r\n    getDx() {\r\n        return this.mouseX - this.mouseXOnDown;\r\n    }\r\n\r\n    getDy() {\r\n        return this.mouseY - this.mouseYOnDown;\r\n    }\r\n}\n\n//# sourceURL=webpack://rubiks-cube/./scripts/dragDetector.js?");

/***/ }),

/***/ "./scripts/pickId.js":
/*!***************************!*\
  !*** ./scripts/pickId.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"colorFromId\": () => (/* binding */ colorFromId),\n/* harmony export */   \"idFromColor\": () => (/* binding */ idFromColor)\n/* harmony export */ });\nfunction colorFromId(id) {\r\n    if (id >= 4294967295) {\r\n        // Max id allowed 256^4 - 2.\r\n        // 255, 255, 255, 255 is the id for the background which would correspond to id 256^4 - 1.\r\n        console.error(\"Id is too large for rgba!\");\r\n        return;\r\n    }\r\n    const x = 256;\r\n    const y = 256 * 256;\r\n    const z = 256 * 256 * 256;\r\n    let aremainder = id % z;\r\n    let alpha = (id - aremainder) / z;\r\n    let bremainder = aremainder % y;\r\n    let blue = (aremainder - bremainder) / y;\r\n    let gremainder = bremainder % x;\r\n    let green = (bremainder - gremainder) / x;\r\n    let red = gremainder;\r\n    return [red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0];\r\n}\r\n\r\nfunction idFromColor(rgba) {\r\n    return rgba[0]\r\n        + rgba[1] * 256\r\n        + rgba[2] * 256 * 256\r\n        + rgba[3] * 256 * 256 * 256;\r\n}\n\n//# sourceURL=webpack://rubiks-cube/./scripts/pickId.js?");

/***/ }),

/***/ "./scripts/scene.js":
/*!**************************!*\
  !*** ./scripts/scene.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buffers\": () => (/* binding */ buffers),\n/* harmony export */   \"cube\": () => (/* binding */ cube),\n/* harmony export */   \"dragDetector\": () => (/* binding */ dragDetector),\n/* harmony export */   \"animateTurn\": () => (/* binding */ animateTurn),\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"initScene\": () => (/* binding */ initScene)\n/* harmony export */ });\n/* harmony import */ var _buffers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffers.js */ \"./scripts/buffers.js\");\n/* harmony import */ var _cube_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cube.js */ \"./scripts/cube.js\");\n/* harmony import */ var _dragDetector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dragDetector.js */ \"./scripts/dragDetector.js\");\n\r\n\r\n\r\n\r\nconst canvas = document.querySelector('#glCanvas');\r\nconst gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n\r\nconst buffers = new _buffers_js__WEBPACK_IMPORTED_MODULE_0__.Buffers();\r\nconst cube = new _cube_js__WEBPACK_IMPORTED_MODULE_1__.CubeLogic();\r\nconst dragDetector = new _dragDetector_js__WEBPACK_IMPORTED_MODULE_2__.DragDetector();\r\n\r\nlet programInfo;\r\n\r\nlet angle = 0.0;\r\nlet isTurning = false;\r\nlet numTurnsQueued = 0;\r\nlet time = Date.now();\r\nlet rotationAxis = [1, 0, 0];\r\nlet onTurnFinish = () => { }\r\n\r\nfunction setRotationAxis(axis, clockwise) {\r\n    let x = clockwise ? -1 : 1;\r\n    if (axis == 0) {\r\n        rotationAxis = [x, 0, 0];\r\n    } else if (axis == 1) {\r\n        rotationAxis = [0, x, 0];\r\n    } else if (axis == 2) {\r\n        rotationAxis = [0, 0, x];\r\n    } else {\r\n        console.error(`Invalid axis '${axis}'`);\r\n    }\r\n}\r\n\r\nfunction animateTurn(newOnTurnFinish) {\r\n    setRotationAxis(cube.axis, cube.clockwise);\r\n\r\n    angle = 0.0;\r\n    time = Date.now();\r\n    isTurning = true;\r\n    onTurnFinish = newOnTurnFinish;\r\n\r\n    numTurnsQueued += 1;\r\n\r\n    render();\r\n}\r\n\r\nfunction render() {\r\n    drawScene();\r\n    requestAnimationFrame(() => {\r\n        updateScene();\r\n    });\r\n}\r\n\r\nfunction updateScene() {\r\n    if (isTurning) {\r\n        const newTime = Date.now();\r\n        angle += (newTime - time) / cube.factor;\r\n        time = newTime;\r\n        if (angle >= Math.PI / 2 || numTurnsQueued > 1) {\r\n            angle = 0.0;\r\n            isTurning = false;\r\n            numTurnsQueued = 0;\r\n            cube.resetAffectedStickers();\r\n            cube.setStickers();\r\n            if (onTurnFinish) onTurnFinish();\r\n        }\r\n\r\n        render();\r\n    }\r\n}\r\n\r\nfunction initScene() {\r\n    if (!gl) {\r\n        alert('Unable to initialize WebGL. Your browser or machine may not support it.');\r\n        return;\r\n    }\r\n\r\n    // Vertex shader program\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n    varying lowp vec4 vColor;\r\n    void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vColor = aVertexColor;\r\n    }\r\n    `;\r\n\r\n    // Fragment shader program\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n    void main(void) {\r\n        gl_FragColor = vColor;\r\n    }\r\n    `;\r\n\r\n    // Initialize a shader program; this is where all the lighting\r\n    // for the vertices and so forth is established.\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    // Collect all the info needed to use the shader program.\r\n    // Look up which attributes our shader program is using\r\n    // for aVertexPosition, aVertexColor and also\r\n    // look up uniform locations.\r\n    programInfo = {\r\n        program: shaderProgram,\r\n        attribLocations: {\r\n            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n            vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),\r\n        },\r\n        uniformLocations: {\r\n            projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n            modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n        }\r\n    };\r\n\r\n    render();\r\n}\r\n\r\nfunction bindPosition(positionBuffer) {\r\n    const numComponents = 3;\r\n    const type = gl.FLOAT;\r\n    const normalize = false;\r\n    const stride = 0;\r\n    const offset = 0;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n    gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexPosition);\r\n}\r\n\r\nfunction bindColor(colorBuffer) {\r\n    const numComponents = 4;\r\n    const type = gl.FLOAT;\r\n    const normalize = false;\r\n    const stride = 0;\r\n    const offset = 0;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n    gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexColor);\r\n}\r\n\r\nfunction readPixels() {\r\n    gl.readPixels(\r\n        dragDetector.pixelX, // x\r\n        dragDetector.pixelY, // y\r\n        1, // width\r\n        1, // height\r\n        gl.RGBA, // format\r\n        gl.UNSIGNED_BYTE, // type\r\n        dragDetector.pixels, // array to hold result\r\n    );\r\n}\r\n\r\nfunction drawElements() {\r\n    gl.drawElements(\r\n        gl.TRIANGLES,\r\n        6,\r\n        gl.UNSIGNED_SHORT, // type\r\n        0, // offset\r\n    );\r\n}\r\n\r\nfunction drawScene() {\r\n    gl.clearDepth(1.0);                 // Clear everything\r\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n    // Create a perspective matrix, a special matrix that is\r\n    // used to simulate the distortion of perspective in a camera.\r\n    // Our field of view is 45 degrees, with a width/height\r\n    // ratio that matches the display size of the canvas\r\n    // and we only want to see objects between 0.1 units\r\n    // and 100 units away from the camera.\r\n\r\n    const fieldOfView = 45 * Math.PI / 180;   // in radians\r\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n    const zNear = 0.1;\r\n    const zFar = 100.0;\r\n    const mat4 = glMatrix.mat4;\r\n    const projectionMatrix = mat4.create();\r\n\r\n    // note: glmatrix.js always has the first argument\r\n    // as the destination to receive the result.\r\n    mat4.perspective(projectionMatrix,\r\n        fieldOfView,\r\n        aspect,\r\n        zNear,\r\n        zFar);\r\n\r\n    // Set the drawing position to the \"identity\" point, which is\r\n    // the center of the scene.\r\n    const modelViewMatrix = mat4.create();\r\n\r\n    // Now move the drawing position a bit to where we want to\r\n    // start drawing the square.\r\n\r\n    mat4.translate(modelViewMatrix,     // destination matrix\r\n        modelViewMatrix,     // matrix to translate\r\n        [-0.0, 0.0, -5.5]);  // amount to translate\r\n\r\n    // Rotate to the starting position such that 3 faces are visible.\r\n    mat4.rotate(\r\n        modelViewMatrix,\r\n        modelViewMatrix,\r\n        Math.PI / 4.5,\r\n        [1, 0, 0],\r\n    );\r\n\r\n    gl.useProgram(programInfo.program);\r\n\r\n    // Set the shader uniforms\r\n    gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n\r\n    const stickers = cube.getStickers();\r\n    const affectedStickers = cube.getAffectedStickers();\r\n\r\n    function drawObjects(range, selectBuffers) {\r\n        for (let i = 0; i < range; i++) {\r\n            let object = buffers.objects[i];\r\n\r\n            // Matrix specific to this object\r\n            const m = mat4.create();\r\n            mat4.rotate(\r\n                m,\r\n                modelViewMatrix,\r\n                affectedStickers[i] ? angle : 0,\r\n                rotationAxis,\r\n            );\r\n\r\n            gl.uniformMatrix4fv(\r\n                programInfo.uniformLocations.modelViewMatrix,\r\n                false,\r\n                m,\r\n            );\r\n\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.indexBuffer);\r\n            const selected = selectBuffers(i);\r\n            if (selected.color == undefined) {\r\n                console.log(selected);\r\n            }\r\n            bindPosition(selected.position);\r\n            bindColor(selected.color);\r\n            drawElements();\r\n        }\r\n    }\r\n\r\n    gl.clearColor(1.0, 1.0, 1.0, 1.0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    drawObjects(\r\n        cube.layersSq * 2,\r\n        (i) => {\r\n            const object = buffers.objects[i];\r\n            return {\r\n                position: object.noGapPositionBuffer,\r\n                color: object.pickingColorBuffer,\r\n            };\r\n        },\r\n    );\r\n\r\n    readPixels();\r\n\r\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    drawObjects(\r\n        cube.numOfStickers,\r\n        (i) => {\r\n            const object = buffers.objects[i];\r\n            return {\r\n                position: object.positionBuffer,\r\n                color: stickers[i],\r\n            };\r\n        },\r\n    );\r\n}\r\n\r\n// Initialize a shader program, so WebGL knows how to draw our data\r\nfunction initShaderProgram(gl, vsSource, fsSource) {\r\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n        return null;\r\n    }\r\n\r\n    return shaderProgram;\r\n}\r\n\r\n// Creates a shader of the given type, uploads the source and compiles it.\r\nfunction loadShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n\r\n    gl.shaderSource(shader, source);\r\n\r\n    gl.compileShader(shader);\r\n\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n\r\n    return shader;\r\n}\n\n//# sourceURL=webpack://rubiks-cube/./scripts/scene.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./scripts/index.ts");
/******/ 	
/******/ })()
;